from typing import List
import numpy as np
from math import cos, sin
from typing import Optional
from utils.linalg import *
from .move2goal import Move2Goal
from .avoid_obstacle import AvoidObstacle
from .utils import wrap2pi, gaussian, LEFT, RIGHT

from utils.arena_utils import ArenaSections, univector_pos_section, Axis, Offsets

class UnivectorField:
    '''
    Main vector field generated by move2goal and avoid obstacle fields. It is used as
    the main reference for any movements.
    
    Parameters:
        ------ Entitys ------
        obstaclesPos        List[Vec2D]: List of obstacles positions.
        obstaclesVelocity   List[Vec2D]: List of obstacles velocities.
        ballPos             Vec2D:       Ball position.
        robotsPos           Vec2D:       Robots position.
        robotsVelocity      Vec2D:       Robots velocity.

        ------ Constants ------
        Radius              float: Move2Goal field radius.
        Kr                  float: Smoothness hyperbolic spiral constant for Move2Goal field.
        K0                  float: Virtual prediction costant for AvoidObstacle field.
        Dmin                float: | Minimum distance that move2goal field can be applied. And 
        |                   |      | avoid-obstacle field is solely applied if the distance
        |                   |      | is less than dmin
        LDelta              float: Gaussian function parameter.

        ------ Subfields ------
        avoidObstacleField  AvoidObstacle: AvoidObstacle field.
        move2Goal           Move2Goal:     Move2Goal field.

    Reference: "Evolutionary Univector Field-based Navigation with Collision Avoidance for Mobile Robot"
    '''
    def __init__(self,
                 obstaclesPos:       List[Vec2D] = [Vec2D.origin()],
                 obstaclesVelocity:  List[Vec2D] = [Vec2D.origin()],
                 ballPos:            Vec2D = Vec2D.origin(),
                 robotsPos:          Vec2D = Vec2D.origin(),
                 robotsVelocity:     Vec2D = Vec2D.origin(),
                 Radius:             Optional[float] = None,
                 Kr:                 Optional[float] = None,
                 K0:                 Optional[float] = None,
                 Dmin:               Optional[float] = None,
                 LDelta:             Optional[float] = None,
                 avoidObstacleField: Optional[AvoidObstacle] = None,
                 move2Goal:          Optional[Move2Goal] = None):
                
        # Entitys
        self.obstaclesPos = obstaclesPos
        self.obstaclesVelocity = obstaclesVelocity
        self.ballPos = ballPos
        self.robotsPos = robotsPos
        self.robotsVelocity = robotsVelocity

        # Field constants
        self.Radius = Radius
        self.Kr = Kr
        self.K0 = K0
        self.Dmin = Dmin
        self.LDelta = LDelta

        # Subfields
        if avoidObstacleField:
            self.avoidObstacleField = avoidObstacleField
        else:
            self.avoidObstacleField = AvoidObstacle(Vec2D.origin(), Vec2D.origin(),
                                         Vec2D.origin(), Vec2D.origin(), self.K0)
        if move2Goal:
            self.move2Goal = move2Goal
        else:
            self.move2Goal = Move2Goal(self.Kr, self.Radius)

    @staticmethod
    def get_attack_goal_axis(attack_goal: bool) -> Vec2D:
        '''
        Returns the attack goal axis.

        Args:
            attack_goal [bool]: Attack goal side.

        Note*
            LEFT  = False
            RIGHT = True
        '''
        return Vec2D.right() if attack_goal == RIGHT else Vec2D.left()

    @staticmethod
    def get_attack_goal_position(attack_goal: bool) -> Vec2D:
        '''
        Returns the goal position based on attack_goal side.

        Args:
            attack_goal [bool]: Attack goal side.

        Note*
            LEFT  = False
            RIGHT = True
        '''
        return Vec2D(attack_goal * 150, 65)

    def update_obstacles(self, obstaclesPos: List[Vec2D], obstaclesVelocity: List[Vec2D]) -> None:
        '''
        Update obstacles positions and velocities method.

        Args:
            obstaclesPos      [Vec2D]: List of obstacles positions.
            obstaclesVelocity [Vec2D]: List of obstacles velocities.
        '''
        self.obstaclesPos = obstaclesPos
        self.obstaclesVelocity = obstaclesVelocity

    def update_robot(self, robotsPos: Vec2D, robotsVelocity: Vec2D) -> None:
        '''
        Update Robot position and velocity method.

        Args:
            robotsPos      [Vec2D]: Robot position.
            robotsVelocity [Vec2D]: Robot velocity.
        '''
        self.robotsPos = robotsPos
        self.robotsVelocity = robotsVelocity

        self.avoidObstacleField.update_robot(self.robotsPos, self.robotsVelocity)

    def update_constants(self, Radius: float, Kr: float, K0: float, Dmin: float, LDelta: float) -> Vec2D:
        '''
        Update field constants and fields.

        Args:
            Radius  [float]: Move2Goal field radius.
            Kr      [float]: Smoothness hyperbolic spiral constant for Move2Goal field.
            K0      [float]: Virtual prediction costant for AvoidObstacle field.
            Dmin    [float]: Minimum distance that move2goal field can be applied. And
            LDelta  [float]: Gaussian function parameter.
        '''
        self.Radius = Radius
        self.Kr = Kr
        self.K0 = K0
        self.Dmin = Dmin
        self.LDelta = LDelta

        self.avoidObstacleField.update_param(self.K0)
        self.move2Goal.update_params(self.Kr, self.Radius)

    def get_angle_vec(self,
                      robotsPos:      Optional[Vec2D] = None,
                      robotsVelocity: Optional[Vec2D] = None,
                      goal_pos:       Optional[Vec2D] = None,
                      goal_axis:      Optional[Vec2D] = None) -> float:
        '''
        Returns the angle vector of the univector field, result of AvoidObstacle and Move2Goal fields combined.
        
        Args:
            robotsPos      [Vec2D]: Robot position.
            robotsVelocity [Vec2D]: Robot velocity.
            goal_pos       [Vec2D]: Goal position.
            goal_axis      [Vec2D]: Goal axis.

        robotsPos and robotsVelocity / goal_pos and goal_axis must be passed together to update the fields,
        otherwise default stored values will be used.
        '''
        if robotsPos and robotsVelocity:
            self.update_robot(robotsPos, robotsVelocity)
        
        if goal_pos and goal_axis:
            self.move2Goal.update_axis(goal_pos, goal_axis)

        centers = []
        # At least one obstacle in the field.
        if self.obstaclesPos:
            for i, _ in enumerate(self.obstaclesPos):
                self.avoidObstacleField.update_obstacle(self.obstaclesPos[i], self.obstaclesVelocity[i])
                center = self.avoidObstacleField.get_virtual_pos()
                centers.append(center)

            distances = [(center - self.robotsPos).norm() for center in centers]
            closest_center = centers[distances.index(min(distances))]
            min_distance = min(distances)

            fi_auf = self.avoidObstacleField.fi_auf(self.robotsPos, closest_center)
        
        # When robot is too close to obstacle, only avoid-obstacle field is applied.
        if min_distance <= self.Dmin and self.obstaclesPos:
            return fi_auf

        fi_tuf = self.move2Goal.fi_tuf(self.robotsPos)

        # When there is no obstacles in the field, only move2goal field is applied.
        if not self.obstaclesPos:
            return fi_tuf
        # Normal case, both fields are applied.
        else:
            gaussian_ = gaussian(min_distance, self.Dmin, self.LDelta)
            difference = wrap2pi(fi_auf - fi_tuf)
            return wrap2pi(fi_tuf + (gaussian_ * difference))
            

    def get_vec_with_ball(self,
                          robotsPos:      Optional[Vec2D] = None,
                          robotsVelocity: Optional[Vec2D] = None,
                          ballPos:        Optional[Vec2D] = None,
                          attack_goal:    bool            = RIGHT) -> Vec2D:
        '''
        Get the angle vector between the robot and the ball.

        Args:
            robotsPos      [Vec2D]: Robot position.
            robotsVelocity [Vec2D]: Robot velocity.
            ballPos        [Vec2D]: Ball position.
            attack_goal    [bool]:  Attack goal side.
        '''
        angle = self.get_angle_with_ball(robotsPos, robotsVelocity, ballPos, attack_goal)
        return Vec2D(cos(angle), sin(angle))

    def get_angle_with_ball(self,
                            robotsPos:      Optional[Vec2D] = None,
                            robotsVelocity: Optional[Vec2D] = None,
                            ballPos:        Optional[Vec2D] = None,
                            attack_goal:    bool            = RIGHT) -> float:
        '''
        Get the angle between the robot and the ball.

        Args:
            robotsPos      [Vec2D]: Robot position.
            robotsVelocity [Vec2D]: Robot velocity.
            ballPos        [Vec2D]: Ball position.
            attack_goal    [bool]:  Attack goal side.
        '''
        ballPos_section = univector_pos_section(ballPos)

        # Arena center section case.
        if ballPos_section in [ArenaSections.CENTER]:
            correct_axis = self.get_attack_goal_position(attack_goal) - ballPos
        else:
            # Arena right side case.
            if attack_goal == RIGHT and ballPos_section in [ArenaSections.RIGHT_DOWN_CORNER, ArenaSections.RIGHT_UP_CORNER]:
                correct_axis = Vec2D.right()
            # Arena left side case.
            elif attack_goal == LEFT and ballPos_section in [ArenaSections.LEFT_DOWN_CORNER, ArenaSections.LEFT_UP_CORNER]:
                correct_axis = Vec2D.left()
            else:
                correct_axis = self.get_correct_axis(ballPos_section, attack_goal)

        offset = self.get_correct_offset(ballPos_section)

        return self.get_angle_vec(robotsPos, robotsVelocity, ballPos, correct_axis - offset)

    def get_correct_axis(self, section: ArenaSections, attack_goal: bool = RIGHT) -> Vec2D:
        '''
        Get correct axis based on arena section and attack goal side.

        Args:
            section     [ArenaSections]: Arena section.
            attack_goal [bool]:          Attack goal side.

        Note*
            LEFT  = False
            RIGHT = True
        '''
        axis = Axis[section.value]
        return axis if attack_goal == RIGHT else axis * -1

    def get_correct_offset(self, section: ArenaSections) -> Vec2D:
        '''
        Get correct offset based on arena section.

        Args:
            section [ArenaSections]: Arena section.
        '''
        return Offsets[section.value]